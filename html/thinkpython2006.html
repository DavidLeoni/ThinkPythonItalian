<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="hevea 2.23">
<link rel="stylesheet" type="text/css" href="thinkpython2.css">
<title>Istruzioni condizionali e ricorsione</title>
</head>
<body>
<a href="thinkpython2005.html"><img src="back.png" ALT="Previous"></a>
<a href="index.html"><img src="up.png" ALT="Up"></a>
<a href="thinkpython2007.html"><img src="next.png" ALT="Next"></a>
<hr>
<table cellpadding=10>

<tr>

<td valign="top" width=100 bgcolor="#b6459a">
</td>

<td valign="top" width=600>

<p>
<a href="http://amzn.to/Owtmjy">Buy this book at Amazon.com</a>

<h1 class="chapter" id="sec57">Chapter 5  Istruzioni condizionali e ricorsione</h1>
<p>L’argomento principale di questo capitolo è l’istruzione <span class="c003">if</span>, che permette di eseguire codice diverso a seconda dello stato del programma. Prima di tutto, vediamo però due nuovi operatori: divisione intera e modulo.</p>
<h2 class="section" id="sec58">5.1  Divisione intera e modulo</h2>
<p>L’operatore di <span class="c009">divisione intera</span>, <code>//</code>, divide due numeri e arrotonda il risultato all’intero inferiore. Ad esempio, supponiamo che la durata di un film sia di 105 minuti, e di volerla esprimere in ore. La normale divisione restituisce un numero decimale:</p><pre class="verbatim">&gt;&gt;&gt; minuti = 105
&gt;&gt;&gt; minuti / 60
1.75
</pre><p>Ma di solito non si esprimono le ore con un numero decimale. La divisione intera dà invece come risultato il numero di ore e tralascia la frazione di ora:</p><pre class="verbatim">&gt;&gt;&gt; minuti = 105
&gt;&gt;&gt; ore = minuti // 60
&gt;&gt;&gt; ore
1
</pre><p>Per ottenere il resto, potete sottrarre dai minuti l’equivalente delle ore:</p><pre class="verbatim">&gt;&gt;&gt; resto = minuti - ore * 60
&gt;&gt;&gt; resto
45
</pre><p><a id="hevea_default299"></a>
<a id="hevea_default300"></a>
<a id="hevea_default301"></a>
<a id="hevea_default302"></a></p><p>Un’alternativa è utilizzare l’<span class="c009">operatore modulo</span>, <code>%</code>, che 
restituisce il resto dell’operazione di divisione tra due numeri interi.</p><pre class="verbatim">&gt;&gt;&gt; resto = minuti % 60
&gt;&gt;&gt; resto
45
</pre><p>L’operatore modulo è più utile di quel che sembra. Per esempio, permette di controllare se un numero intero è divisibile per un altro: se
<span class="c003">x % y</span> è zero, significa che <span class="c003">x</span> è divisibile per <span class="c003">y</span>.
<a id="hevea_default303"></a></p><p>Inoltre, può essere usato per estrarre la cifra più a destra di un numero: <span class="c003">x % 10</span> restituisce la cifra più a destra del numero <span class="c003">x</span> (in base 10). Allo stesso modo, <span class="c003">x % 100</span> restituisce le ultime due cifre.</p><p>Per chi usa Python 2, la divisione funziona in modo diverso. L’operatore di divisione intera non esiste, e quello di divisione, <code>/</code>, esegue una divisione intera se entrambi gli operandi sono interi, mentre il risultato è un decimale a virgola mobile se almeno uno degli operandi è un decimale.
<a id="hevea_default304"></a></p>
<h2 class="section" id="sec59">5.2  Espressioni booleane</h2>
<p>
<a id="hevea_default305"></a>
<a id="hevea_default306"></a></p><p>Un’<span class="c009">espressione booleana</span> è un’espressione che può essere o vera o falsa. Gli esempi che seguono usano l’operatore <span class="c003">==</span>, confrontano due valori e restituiscono <span class="c003">True</span> (vero) se sono uguali, <span class="c003">False</span> (falso) altrimenti:</p><pre class="verbatim">&gt;&gt;&gt; 5 == 5
True
&gt;&gt;&gt; 5 == 6
False
</pre><p><span class="c003">True</span> e <span class="c003">False</span> sono valori speciali che sono di tipo <span class="c003">bool</span>; non sono delle stringhe:
<a id="hevea_default307"></a>
<a id="hevea_default308"></a>
<a id="hevea_default309"></a>
<a id="hevea_default310"></a>
<a id="hevea_default311"></a>
<a id="hevea_default312"></a></p><pre class="verbatim">&gt;&gt;&gt; type(True)
&lt;class 'bool'&gt;
&gt;&gt;&gt; type(False)
&lt;class 'bool'&gt;
</pre><p>L’operatore <span class="c003">==</span> è uno degli <span class="c009">operatori di confronto</span>; gli altri sono:</p><pre class="verbatim">      x != y               # x è diverso da y
      x &gt; y                # x è maggiore di y
      x &lt; y                # x è minore di y
      x &gt;= y               # x è maggiore o uguale a y
      x &lt;= y               # x è minore o uguale a y
</pre><p>Queste operazioni vi saranno familiari, tuttavia i simboli in Python sono diversi da quelli usati comunemente in matematica. Un errore frequente è quello di usare il simbolo di uguale(<span class="c003">=</span>) invece del doppio uguale
(<span class="c003">==</span>). Ricordate che <span class="c003">=</span> è un operatore di assegnazione, mentre
<span class="c003">==</span> è un operatore di confronto. Inoltre in Python non esistono simboli del
tipo <span class="c003">=&lt;</span> o <span class="c003">=&gt;</span>.
<a id="hevea_default313"></a>
<a id="hevea_default314"></a></p>
<h2 class="section" id="sec60">5.3  Operatori logici</h2>
<p>
<a id="hevea_default315"></a>
<a id="hevea_default316"></a></p><p>Ci sono tre <span class="c009">operatori logici</span>: <span class="c003">and</span>, <span class="c003">or</span>, e <span class="c003">not</span>. Il significato di questi operatori è simile al loro significato comune (e, o, non): per esempio, l’espressione <span class="c003">x &gt; 0 and x &lt; 10</span> è vera solo se sono vere <em>entrambe</em> le condizioni, cioè <span class="c003">x</span> è più grande di 0 <em>e</em> più piccolo di 10.
<a id="hevea_default317"></a>
<a id="hevea_default318"></a>
<a id="hevea_default319"></a>
<a id="hevea_default320"></a>
<a id="hevea_default321"></a>
<a id="hevea_default322"></a></p><p>L’espressione <span class="c003">n%2 == 0 or n%3 == 0</span> invece è vera se si verifica <em>almeno una</em> delle due condizioni e cioè se il numero è divisibile per 2 <em>o</em> per 3 (o per entrambi).</p><p>Infine, l’operatore <span class="c003">not</span> nega il valore di un’espressione booleana,
trasformando in falsa un’espressione vera e viceversa. Così, <span class="c003">not (x &gt; y)</span> è vera se <span class="c003">x &gt; y</span> è falsa, cioè se <span class="c003">x</span> è minore o uguale a <span class="c003">y</span>.</p><p>In senso stretto, gli operandi degli operatori logici dovrebbero essere delle espressioni booleane, ma da questo punto di vista Python non è troppo fiscale: infatti ogni numero diverso da zero viene considerato <span class="c003">True</span>, e lo zero è considerato <span class="c003">False</span>.</p><pre class="verbatim">&gt;&gt;&gt; 42 and True
True
</pre><p>Questa flessibilità può essere utile, ma ci sono alcune sottigliezze che potrebbero confondere. È preferibile evitarla (a meno che non sappiate quello che state facendo).</p>
<h2 class="section" id="sec61">5.4  Esecuzione condizionale</h2>
<p>
<a id="conditional.execution"></a></p><p><a id="hevea_default323"></a>
<a id="hevea_default324"></a>
<a id="hevea_default325"></a>
<a id="hevea_default326"></a>
Per poter scrivere programmi utili, c’è molto spesso la necessità di valutare delle condizioni e di variare il comportamento del programma a seconda del risultato della valutazione. Le <span class="c009">istruzioni condizionali</span> ci offrono questa possibilità. La forma più semplice è l’istruzione <span class="c003">if</span> (“se” in inglese):</p><pre class="verbatim">if x &gt; 0:
    print("x è positivo")
</pre><p>L’espressione booleana dopo l’istruzione <span class="c003">if</span> è chiamata <span class="c009">condizione</span>. L’istruzione indentata che segue i due punti della riga if, viene eseguita solo se la condizione è vera. Se la condizione è falsa non viene eseguito nulla.
<a id="hevea_default327"></a>
<a id="hevea_default328"></a></p><p>Come nel caso della definizione di funzione, la struttura dell’istruzione <span class="c003">if</span> è costituita da un’intestazione seguita da un corpo indentato. Le istruzioni come questa vengono chiamate <span class="c009">istruzioni composte</span>.</p><p>Non c’è limite al numero di istruzioni che possono comparire nel corpo, ma deve sempre essercene almeno una. In qualche occasione può essere utile avere un corpo vuoto, ad esempio quando il codice corrispondente non è ancora stato scritto ma si desidera ugualmente provare il programma. In questo caso si può usare l’istruzione <span class="c003">pass</span>, che serve solo da segnaposto temporaneo e nulla più:
<a id="hevea_default329"></a>
<a id="hevea_default330"></a></p><pre class="verbatim">if x &lt; 0:
    pass          # scrivere cosa fare con i valori negativi!
</pre>
<h2 class="section" id="sec62">5.5  Esecuzione alternativa</h2>
<p>
<a id="alternative.execution"></a>
<a id="hevea_default331"></a>
<a id="hevea_default332"></a>
<a id="hevea_default333"></a></p><p>Una seconda forma di istruzione <span class="c003">if</span> è l’<span class="c009">esecuzione alternativa</span>,
nella quale ci sono due azioni possibili, e il valore della condizione
determina quale delle due debba essere eseguita e quale no. La sintassi è:</p><pre class="verbatim">if x % 2 == 0:
    print("x è pari")
else:
    print("x è dispari")
</pre><p>Se il resto della divisione di <span class="c003">x</span> per 2 è zero, significa che <span class="c003">x</span> è un numero pari, e il programma mostra il messaggio appropriato. Se invece la condizione è falsa, viene eseguita la serie di istruzioni descritta dopo la riga <span class="c003">else</span> (che in inglese significa “altrimenti”). In ogni caso, una delle due alternative sarà sempre eseguita. Le due alternative sono chiamate <span class="c009">ramificazioni</span>, perché rappresentano dei bivi nel flusso di esecuzione del programma.
<a id="hevea_default334"></a></p>
<h2 class="section" id="sec63">5.6  Condizioni in serie</h2>
<p>
<a id="hevea_default335"></a>
<a id="hevea_default336"></a></p><p>Talvolta occorre tenere conto di più di due possibili sviluppi, pertanto possiamo aver bisogno di più di due ramificazioni. Un modo per esprimere questo tipo di calcolo sono le <span class="c009">condizioni in serie</span>:</p><pre class="verbatim">if x &lt; y:
    print("x è minore di y")
elif x &gt; y:
    print("x è maggiore di y")
else:
    print("x e y sono uguali")
</pre><p><span class="c003">elif</span> è l’abbreviazione di <em>else if</em>, che in inglese significa “altrimenti se”. Anche in questo caso, solo uno dei rami verrà eseguito, a seconda dell’esito del confronto tra <span class="c003">x</span> e <span class="c003">y</span>. Non c’è alcun limite al numero di istruzioni <span class="c003">elif</span>. Se esiste una clausola <span class="c003">else</span>, deve essere scritta per ultima, ma non è obbligatoria; il ramo corrispondente viene eseguito solo quando tutte le condizioni precedenti sono false.
<a id="hevea_default337"></a>
<a id="hevea_default338"></a></p><pre class="verbatim">if scelta == 'a':
    disegna_a()
elif scelta == 'b':
    disegna_b()
elif scelta == 'c':
    disegna_c()
</pre><p>Le condizioni vengono controllate nell’ordine in cui sono state scritte: se la prima è falsa viene controllata la seconda e così via. Non appena una condizione risulta vera, viene eseguito il ramo corrispondente e l’intera istruzione <span class="c003">if</span> si conclude. In ogni caso, anche se risultassero vere altre condizioni successive, dopo l’esecuzione della prima queste ultime verranno trascurate. </p>
<h2 class="section" id="sec64">5.7  Condizioni nidificate</h2>
<p>
<a id="hevea_default339"></a></p><p>Si può anche inserire un’istruzione condizionale nel corpo di un’altra istruzione condizionale. Possiamo scrivere l’esempio del paragrafo precedente anche in questo modo:</p><pre class="verbatim">if x == y:
    print("x e y sono uguali")
else:
    if x &lt; y:
        print("x è minore di y")
    else:
        print("x è maggiore di y")
</pre><p>La prima condizione esterna (<span class="c003">if x == y</span>) contiene due rami: il primo contiene un’istruzione semplice, il secondo un’altra istruzione <span class="c003">if</span> che a sua volta prevede un’ulteriore ramificazione. Entrambi i rami del secondo <span class="c003">if</span> sono istruzioni di stampa, ma potrebbero anche contenere a loro volta ulteriori istruzioni condizionali.</p><p>Sebbene l’indentazione delle istruzioni aiuti a rendere evidente la struttura, le <span class="c009">condizioni nidificate</span> diventano rapidamente difficili da leggere, quindi è meglio usarle con moderazione.</p><p>Qualche volta, gli operatori logici permettono di semplificare le istruzioni condizionali nidificate:</p><pre class="verbatim">if 0 &lt; x:
    if x &lt; 10:
        print("x è un numero positivo a una cifra.")
</pre><p>L’istruzione di stampa è eseguita solo se entrambe le condizioni si verificano. Possiamo allora usare l’operatore booleano <span class="c003">and</span> per combinarle:</p><pre class="verbatim">if 0 &lt; x and x &lt; 10:
    print("x è un numero positivo a una cifra.")
</pre><p>Per una condizione di questo tipo, Python consente anche un’opzione sintattica più concisa:</p><pre class="verbatim">if 0 &lt; x &lt; 10:
    print("x è un numero positivo a una cifra.")
</pre>
<h2 class="section" id="sec65">5.8  Ricorsione</h2>
<p>
<a id="recursion"></a>
<a id="hevea_default340"></a></p><p>Abbiamo visto che è del tutto normale che una funzione ne chiami un’altra, ma è anche consentito ad una funzione di chiamare se stessa. L’utilità può non essere immediatamente evidente, ma questa è una delle cose più magiche che un programma possa fare. Per fare un esempio, diamo un’occhiata a questa funzione:</p><pre class="verbatim">def contoallarovescia(n):
    if n &lt;= 0:
        print("Via!")
    else:
        print(n)
        contoallarovescia(n-1)
</pre><p>Se <span class="c003">n</span> vale 0 o è negativo, scrive la parola “Via!”.
Altrimenti scrive il numero <span class="c003">n</span> e poi chiama la funzione <span class="c003">contoallarovescia</span> (cioè se stessa) passando un argomento che vale <span class="c003">n-1</span>.</p><p>Cosa succede quando chiamiamo la funzione in questo modo?</p><pre class="verbatim">&gt;&gt;&gt; contoallarovescia(3)
</pre><p>L’esecuzione di <span class="c003">contoallarovescia</span> inizia da <span class="c003">n=3</span>, e dato che
<span class="c003">n</span> è maggiore di 0, stampa il valore 3, poi chiama se stessa...</p><blockquote class="quote">
L’esecuzione di <span class="c003">contoallarovescia</span> inizia da <span class="c003">n=2</span>, e dato che
<span class="c003">n</span> è maggiore di 0, stampa il valore 2, poi chiama se stessa...<blockquote class="quote">
L’esecuzione di <span class="c003">contoallarovescia</span> inizia da <span class="c003">n=1</span>, e dato che
<span class="c003">n</span> è maggiore di 0, stampa il valore 1, poi chiama se stessa...<blockquote class="quote">
L’esecuzione di <span class="c003">contoallarovescia</span> inizia da <span class="c003">n=0</span>, e dato che <span class="c003">n</span> è uguale a 0, stampa la parola “Via!” e poi ritorna.
</blockquote><p>La funzione <span class="c003">contoallarovescia</span> che aveva dato <span class="c003">n=1</span> ritorna.
</p></blockquote><p>La funzione <span class="c003">contoallarovescia</span> che aveva dato <span class="c003">n=2</span> ritorna.
</p></blockquote><p>La funzione <span class="c003">contoallarovescia</span> che aveva dato <span class="c003">n=3</span> ritorna.</p><p>E infine ritorniamo in <code>__main__</code>. Il risultato finale è questo:
<a id="hevea_default341"></a></p><pre class="verbatim">3
2
1
Via!
</pre><p>Una funzione che chiama se stessa si dice <span class="c009">ricorsiva</span> e la procedura che la esegue è detta <span class="c009">ricorsione</span>.
<a id="hevea_default342"></a>
<a id="hevea_default343"></a></p><p>Come secondo esempio, scriviamo una funzione che stampi una data stringa per <span class="c003">n</span> volte.</p><pre class="verbatim">def stampa_n(s, n):
    if n &lt;= 0:
        return
    print(s)
    stampa_n(s, n-1)
</pre><p>Se <span class="c003">n &lt;= 0</span> l’<span class="c009">istruzione di ritorno</span> <span class="c003">return</span> provoca l’uscita dalla funzione. Il flusso dell’esecuzione torna immediatamente al chiamante, e le righe rimanenti della funzione non vengono eseguite.
<a id="hevea_default344"></a>
<a id="hevea_default345"></a></p><p>Il resto della funzione è simile a <span class="c003">contoallarovescia</span>: visualizza la stringa <span class="c003">s</span> e chiama se stessa per <span class="c008">n</span>−1 altre volte. Il numero di righe risultanti sarà <span class="c003">1 + (n - 1)</span>, che corrisponde a
<span class="c003">n</span>.</p><p>Per esempi semplici come questi, è forse più facile usare un ciclo <span class="c003">for</span>. Vedremo però più avanti degli esempi difficili da scrivere con un ciclo <span class="c003">for</span> ma facili con la ricorsione; meglio quindi cominciare subito a prendere mano.
<a id="hevea_default346"></a>
<a id="hevea_default347"></a></p>
<h2 class="section" id="sec66">5.9  Diagrammi di stack delle funzioni ricorsive</h2>
<p>
<a id="recursive.stack"></a>
<a id="hevea_default348"></a>
<a id="hevea_default349"></a>
<a id="hevea_default350"></a></p><p>Nel Paragrafo <a href="thinkpython2004.html#stackdiagram">3.9</a>, abbiamo usato un diagramma di stack per rappresentare lo stato di un programma durante una chiamata di funzione. Lo stesso tipo di diagramma può servire a capire come lavora una funzione ricorsiva.</p><p>Ogni volta che una funzione viene chiamata, Python crea un nuovo frame contenente le variabili locali definite all’interno della funzione ed i suoi parametri. Nel caso di una funzione ricorsiva, possono esserci contemporaneamente più frame riguardanti una stessa funzione.</p><p>La Figura <a href="#fig.stack2">5.1</a> mostra il diagramma di stack della funzione <span class="c003">contoallarovescia</span> chiamata con <span class="c003">n = 3</span>.</p><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython2005.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 5.1: Diagramma di stack.</td></tr>
</table></div>
<a id="fig.stack2"></a>
<div class="center"><hr class="c019"></div></blockquote><p>Come al solito, il livello superiore dello stack è il frame di <code>__main__</code>.
Questo frame è vuoto, perché in questo caso non vi abbiamo creato alcuna variabile né abbiamo passato alcun parametro.
<a id="hevea_default351"></a>
<a id="hevea_default352"></a></p><p>I quattro frame di <span class="c003">contoallarovescia</span> hanno valori diversi del parametro <span class="c003">n</span>. Il livello inferiore dello stack, dove <span class="c003">n=0</span>, è chiamato <span class="c009">caso base</span>. Esso non effettua ulteriori chiamate ricorsive, quindi non ci sono ulteriori frame.</p><p>Come esercizio, disegnate il diagramma di stack della funzione <code>stampa_n</code> chiamata con <code>s='Ciao'</code> e <span class="c003">n=2</span>. Poi, scrivete una funzione di nome <code>fai_n</code> che accetti come argomenti un oggetto funzione e un numero <span class="c003">n</span>, e che chiami per <span class="c003">n</span> volte la funzione data.</p>
<h2 class="section" id="sec67">5.10  Ricorsione infinita</h2>
<p>
<a id="hevea_default353"></a>
<a id="hevea_default354"></a></p><p><a id="hevea_default355"></a></p><p>Se una ricorsione non raggiunge mai un caso base, la chiamata alla funzione viene eseguita all’infinito ed in teoria il programma non giunge mai alla fine. Questa situazione è conosciuta come <span class="c009">ricorsione infinita</span>, e di solito non è considerata una buona cosa.
Questo è un programma minimo che genera una ricorsione infinita:</p><pre class="verbatim">def ricorsiva():
    ricorsiva()
</pre><p>Nella maggior parte degli ambienti, un programma con una ricorsione infinita non viene eseguito davvero all’infinito. Python stampa un messaggio di errore quando è stato raggiunto il massimo livello di ricorsione possibile:
<a id="hevea_default356"></a>
<a id="hevea_default357"></a></p><pre class="verbatim">  File "&lt;stdin&gt;", line 2, in ricorsiva
  File "&lt;stdin&gt;", line 2, in ricorsiva
  File "&lt;stdin&gt;", line 2, in ricorsiva
                  .   
                  .
                  .
  File "&lt;stdin&gt;", line 2, in ricorsiva
RuntimeError: Maximum recursion depth exceeded
</pre><p>Questo traceback è un po’ più lungo di quello che abbiamo visto nel capitolo precedente. Quando si verifica l’errore, nello stack ci sono oltre 1000 frame di chiamata di <span class="c003">ricorsiva</span>!</p><p>Se vi imbattete accidentalmente in una ricorsione infinita, rivedete la vostra funzione per accertare che esista un caso base che non genera una chiamata ricorsiva. E se c’è un caso base, controllate che venga sicuramente raggiunto.</p>
<h2 class="section" id="sec68">5.11  Input da tastiera</h2>
<p>
<a id="hevea_default358"></a></p><p>I programmi che abbiamo scritto finora non accettano inserimenti di dati da parte dell’operatore, e si limitano a eseguire sempre le stesse operazioni.</p><p>Python comprende una funzione predefinita chiamata <code>input</code> che sospende il programma ed attende che l’operatore scriva qualcosa e confermi poi l’inserimento premendo il tasto <span class="c005">Invio</span> o <span class="c005">Enter</span>. A quel punto il programma riprende e <code>input</code> restituisce ciò che l’operatore ha inserito sotto forma di stringa. In Python 2, la funzione si chiama <code>raw_input</code> .
<a id="hevea_default359"></a>
<a id="hevea_default360"></a>
<a id="hevea_default361"></a></p><pre class="verbatim">&gt;&gt;&gt; testo = input()
Cosa stai aspettando?
&gt;&gt;&gt; testo
'Cosa stai aspettando?'
</pre><p>Prima di chiamare la funzione, è buona norma stampare un messaggio che informa l’utente di ciò che deve inserire. Questo messaggio è chiamato prompt, e può essere passato come argomento a <code>input</code> :
<a id="hevea_default362"></a></p><pre class="verbatim">&gt;&gt;&gt; nome = input('Come...ti chiami?\n')
Come...ti chiami?
Artu', Re dei Bretoni!
&gt;&gt;&gt; nome
'Artu', Re dei Bretoni!'
</pre><p>La sequenza <code>\n</code> alla fine del prompt rappresenta un <span class="c009">ritorno a capo</span>,
un carattere speciale che provoca un’interruzione di riga. Ecco perché l’input dell’utente compare sulla riga successiva sotto al prompt.
<a id="hevea_default363"></a></p><p>Se il valore da inserire è un intero possiamo provare a convertire il valore inserito in <span class="c003">int</span>:</p><pre class="verbatim">&gt;&gt;&gt; prompt = "Qual è la velocità in volo di una rondine?\n"
&gt;&gt;&gt; velocita = input(prompt)
Qual è la velocità in volo di una rondine?
42
&gt;&gt;&gt; int(velocita)
42
</pre><p>Ma se la stringa inserita contiene qualcosa di diverso da dei numeri, si verifica un errore:</p><pre class="verbatim">&gt;&gt;&gt; velocita = input(prompt)
Qual è la velocità in volo di una rondine?
Cosa intendi, una rondine europea o africana?
&gt;&gt;&gt; int(velocita)
ValueError: invalid literal for int() with base 10
</pre><p>Vedremo più avanti come trattare questo tipo di errori.
<a id="hevea_default364"></a>
<a id="hevea_default365"></a></p>
<h2 class="section" id="sec69">5.12  Debug</h2>
<p>
<a id="whitespace"></a>
<a id="hevea_default366"></a>
<a id="hevea_default367"></a></p><p>Quando si verifica un errore di sintassi o di runtime, il messaggio d’errore contiene molte informazioni, ma può essere sovrabbondante. Di solito le parti più utili sono:</p><ul class="itemize"><li class="li-itemize">Che tipo di errore era, e</li><li class="li-itemize">Dove si è verificato.</li></ul><p>Gli errori di sintassi di solito sono facili da trovare, con qualche eccezione. Gli spaziatori possono essere insidiosi, perché spazi e tabulazioni non sono visibili e siamo abituati a non tenerne conto.
<a id="hevea_default368"></a></p><pre class="verbatim">&gt;&gt;&gt; x = 5
&gt;&gt;&gt;  y = 6
  File "&lt;stdin&gt;", line 1
    y = 6
    ^
IndentationError: unexpected indent
</pre><p>In questo esempio, il problema è che la seconda riga è erroneamente indentata di uno spazio, mentre dovrebbe stare al margine sinistro. Ma il messaggio di errore punta su <span class="c003">y</span>, portando fuori strada. In genere, i messaggi di errore indicano dove il problema è venuto a galla, ma il vero errore potrebbe essere in un punto precedente del codice, a volte anche nella riga precedente.</p><p><a id="hevea_default369"></a></p><p>Lo stesso vale per gli errori di runtime. </p><p>Supponiamo di voler calcolare un rapporto segnale/rumore in decibel. La formula è
<span class="c008">SNR</span><sub><span class="c008">db</span></sub> = 10 log<sub>10</sub> (<span class="c008">P</span><sub><span class="c008">segnale</span></sub> / <span class="c008">P</span><sub><span class="c008">rumore</span></sub>). In Python si può scrivere:</p><pre class="verbatim">import math
potenza_segnale = 9
potenza_rumore = 10
rapporto = potenza_segnale // potenza_rumore
decibel = 10 * math.log10(rapporto)
print(decibel)
</pre><p>Se avviate questo programma, compare un messaggio di errore.
<a id="hevea_default370"></a>
<a id="hevea_default371"></a></p><pre class="verbatim">Traceback (most recent call last):
  File "snr.py", line 5, in ?
    decibel = 10 * math.log10(rapporto)
ValueError: math domain error
</pre><p>Il messaggio punta alla riga 5, ma lì non c’è niente di sbagliato. Per trovare il vero errore, può essere utile stampare il valore di <span class="c003">rapporto</span>, che risulta essere 0. Il problema sta nella riga 4, perché calcola una divisione intera anziché una normale divisione.
<a id="hevea_default372"></a></p><p>Prendetevi la briga di leggere attentamente i messaggi di errore, ma non date per scontato che tutto quello che dicono sia esatto.</p>
<h2 class="section" id="sec70">5.13  Glossario</h2>
<dl class="description"><dt class="dt-description"><span class="c009">divisione intera:</span></dt><dd class="dd-description"> Operatore, avente simbolo <span class="c003">//</span>, che divide due numeri e arrotonda il risultato all’intero inferiore (ovvero, verso l’infinito negativo).
<a id="hevea_default373"></a></dd><dt class="dt-description"><span class="c009">operatore modulo:</span></dt><dd class="dd-description"> Operatore matematico, denotato con il segno di percentuale (<span class="c003">%</span>), che restituisce il resto della divisione tra due operandi
interi.
<a id="hevea_default374"></a>
<a id="hevea_default375"></a></dd><dt class="dt-description"><span class="c009">espressione booleana:</span></dt><dd class="dd-description"> Espressione il cui valore è o vero 
(<span class="c003">True</span>) o falso (<span class="c003">False</span>).
<a id="hevea_default376"></a></dd><dt class="dt-description"><span class="c009">operatore di confronto:</span></dt><dd class="dd-description"> Un operatore che confronta due valori detti operandi: <span class="c003">==</span>, <span class="c003">!=</span>, <span class="c003">&gt;</span>, <span class="c003">&lt;</span>, <span class="c003">&gt;=</span>, e <span class="c003">&lt;=</span>.</dd><dt class="dt-description"><span class="c009">operatore logico:</span></dt><dd class="dd-description"> Un operatore che combina due espressioni booleane: <span class="c003">and</span>, <span class="c003">or</span>, e <span class="c003">not</span>.</dd><dt class="dt-description"><span class="c009">istruzione condizionale:</span></dt><dd class="dd-description"> Istruzione che controlla il flusso di esecuzione del programma a seconda del verificarsi o meno di certe condizioni.
<a id="hevea_default377"></a></dd><dt class="dt-description"><span class="c009">condizione:</span></dt><dd class="dd-description"> Espressione booleana in un’istruzione condizionale che determina quale ramificazione debba essere seguita dal flusso di esecuzione.
<a id="hevea_default378"></a></dd><dt class="dt-description"><span class="c009">istruzione composta:</span></dt><dd class="dd-description"> Istruzione che consiste di un’intestazione terminante con i due punti (:) e di un corpo composto di una o più istruzioni
indentate rispetto all’intestazione.
<a id="hevea_default379"></a></dd><dt class="dt-description"><span class="c009">ramificazione:</span></dt><dd class="dd-description"> Una delle sequenze di istruzioni alternative scritte in una istruzione condizionale.
<a id="hevea_default380"></a></dd><dt class="dt-description"><span class="c009">condizioni in serie:</span></dt><dd class="dd-description"> Istruzione condizionale con una serie di ramificazioni alternative.
<a id="hevea_default381"></a></dd><dt class="dt-description"><span class="c009">condizione nidificata (o annidata):</span></dt><dd class="dd-description"> Un’istruzione condizionale inserita in una ramificazione di un’altra istruzione condizionale.
<a id="hevea_default382"></a></dd><dt class="dt-description"><span class="c009">istruzione di ritorno:</span></dt><dd class="dd-description"> Un’istruzione che termina immediatamente una funzione e ritorna al chiamante.</dd><dt class="dt-description"><span class="c009">ricorsione:</span></dt><dd class="dd-description"> Procedura che chiama la stessa funzione attualmente in esecuzione.
<a id="hevea_default383"></a></dd><dt class="dt-description"><span class="c009">caso base:</span></dt><dd class="dd-description"> Ramificazione di un’istruzione condizionale, posta in una funzione ricorsiva, che non esegue a sua volta una chiamata ricorsiva.
<a id="hevea_default384"></a></dd><dt class="dt-description"><span class="c009">ricorsione infinita:</span></dt><dd class="dd-description"> Una ricorsione priva di un caso base, oppure che non lo raggiunge mai. Nell’evenienza, causa un errore in esecuzione.
<a id="hevea_default385"></a></dd></dl>
<h2 class="section" id="sec71">5.14  Esercizi</h2>
<div class="theorem"><span class="c009">Esercizio 1</span>  <p><em>Il modulo <span class="c003">time</span> contiene una funzione, anch’essa di nome <span class="c003">time</span>, che restituisce l’attuale GMT (Tempo Medio di Greenwich) riferito ad un “tempo zero”, che è un momento arbitrario usato come punto di riferimento. Nei sistemi UNIX, questo “tempo zero” è il 1 gennaio 1970.</em></p><pre class="verbatim"><em>&gt;&gt;&gt; import time
&gt;&gt;&gt; time.time()
1437746094.5735958
</em></pre><p><em>Realizzate uno script che acquisisca il tempo attuale e lo converta in un tempo in ore, minuti e secondi, più i giorni trascorsi dal “tempo zero”.</em></p></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 2</span>  
<a id="hevea_default386"></a><p><em>L’ultimo teorema di Fermat afferma che non esistono interi positivi
</em><span class="c008">a</span><em>, </em><span class="c008">b</span><em>, e </em><span class="c008">c</span><em> tali che</em></p><table class="display dcenter"><tr class="c016"><td class="dcell"><span class="c008">a</span><sup><span class="c008">n</span></sup> + <span class="c008">b</span><sup><span class="c008">n</span></sup> = <span class="c008">c</span><sup><span class="c008">n</span></sup> </td></tr>
</table><p><em>
per qualsiasi valore di </em><span class="c008">n</span><em> maggiore di 2.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete una funzione di nome <code>verifica_fermat</code> che richieda quattro parametri—<span class="c003">a</span>, <span class="c003">b</span>, <span class="c003">c</span> e <span class="c003">n</span>—e controlli se il teorema regge. Se </em><span class="c008">n</span><em> è maggiore di 2 e fosse</em><table class="display dcenter"><tr class="c016"><td class="dcell"><span class="c008"><em>a</em></span><sup><span class="c008"><em>n</em></span></sup><em> + <span class="c008">b</span></em><sup><span class="c008"><em>n</em></span></sup><em> = <span class="c008">c</span></em><sup><span class="c008"><em>n</em></span></sup><em> </em></td></tr>
</table><p><em>
il programma dovrebbe visualizzare: “Santi Numi, Fermat si è sbagliato!”,
altrimenti: “No, questo non è vero.”</em></p></li><li class="li-enumerate"><em>Scrivete una funzione che chieda all’utente di inserire valori di <span class="c003">a</span>, <span class="c003">b</span>, <span class="c003">c</span> e <span class="c003">n</span>, li converta in interi e usi <code>verifica_fermat</code> per controllare se violano il teorema di Fermat.</em></li></ol></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 3</span>  
<a id="hevea_default387"></a><p><em>Dati tre bastoncini, può essere possibile o meno riuscire a sistemarli in modo da formare un triangolo. Per esempio, se uno dei bastoncini misura 12 centimetri e gli altri due 1 centimetro, non riuscirete a far toccare le estremità di tutti e tre i bastoncini. Date tre lunghezze, c’è una semplice regola per controllare se è possibile formare un triangolo:</em></p><blockquote class="quotation"><em>
Se una qualsiasi delle tre lunghezze è maggiore della somma delle altre due, non potete formare un triangolo. (Se la somma di due lunghezze è uguale alla terza, si ha un triangolo “degenere”.)
</em></blockquote><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete una funzione di nome <code>triangolo</code> che riceva tre interi come argomenti e che mostri “Si”’ o “No”, a seconda che si possa o meno formare un triangolo con dei bastoncini delle tre lunghezze date.</em></li><li class="li-enumerate"><em>Scrivete una funzione che chieda all’utente di inserire tre lunghezze, le converta in interi, e le passi a <code>triangolo</code> per verificare se si possa o meno formare un triangolo.</em></li></ol></div><p><br>

</p><div class="theorem"><span class="c009">Esercizio 4</span>  <p><em>Qual è l’output del seguente programma?
Disegnate un diagramma di stack che illustri lo stato del programma nel momento in cui stampa il risultato.</em></p><pre class="verbatim"><em>def ricorsione(n, s):
    if n == 0:
        print(s)
    else:
        ricorsione(n-1, n+s)

ricorsione(3, 0)
</em></pre><ol class="enumerate" type=1><li class="li-enumerate"><em>Cosa succede se chiamate la funzione in questo modo: <span class="c003">ricorsione(-1, 0)</span>?</em></li><li class="li-enumerate"><em>Scrivete una stringa di documentazione che spieghi tutto quello che serve per usare questa funzione (e niente di più).</em></li></ol></div><p>Gli esercizi seguenti utilizzano il modulo turtle, descritto nel Capitolo <a href="thinkpython2005.html#turtlechap">4</a>:
<a id="hevea_default388"></a></p><p><br>

</p><div class="theorem"><span class="c009">Esercizio 5</span>  <p><em>Leggete la seguente funzione e cercate di capire cosa fa (vedere gli esempi nel Capitolo </em><a href="thinkpython2005.html#turtlechap"><em>4</em></a><em>). Quindi eseguitela per controllare se avevate indovinato.</em></p><pre class="verbatim"><em>def disegna(t, lunghezza, n):
    if n == 0:
        return
    angolo = 50
    t.fd(lunghezza*n)
    t.lt(angolo)
    disegna(t, lunghezza, n-1)
    t.rt(2*angolo)
    disegna(t, lunghezza, n-1)
    t.lt(angolo)
    t.bk(lunghezza*n)
</em></pre></div><blockquote class="figure"><div class="center"><hr class="c019"></div>
<div class="center"><img src="thinkpython2006.png"></div>
<div class="caption"><table class="c001 cellpading0"><tr><td class="c017">Figure 5.2: Una curva di Koch.</td></tr>
</table></div>
<a id="fig.koch"></a>
<div class="center"><hr class="c019"></div></blockquote><p><br>

</p><div class="theorem"><span class="c009">Esercizio 6</span>  
<a id="hevea_default389"></a><p><em>La curva di Koch è un frattale che somiglia a quello in Figura </em><a href="#fig.koch"><em>5.2</em></a><em>. Per disegnare una curva di Koch di lunghezza </em><span class="c008">x</span><em>, dovete:</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Disegnare una curva di Koch di lunghezza </em><span class="c008">x</span>/3<em>.</em></li><li class="li-enumerate"><em>Girare a sinistra di 60 gradi.</em></li><li class="li-enumerate"><em>Disegnare una curva di Koch di lunghezza </em><span class="c008">x</span>/3<em>.</em></li><li class="li-enumerate"><em>Girare a destra di 120 gradi.</em></li><li class="li-enumerate"><em>Disegnare una curva di Koch di lunghezza </em><span class="c008">x</span>/3<em>.</em></li><li class="li-enumerate"><em>Girare a sinistra di 60 gradi.</em></li><li class="li-enumerate"><em>Disegnare una curva di Koch di lunghezza </em><span class="c008">x</span>/3<em>.</em></li></ol><p><em>Ad eccezione di quando </em><span class="c008">x</span><em> è minore di 3: in questo caso si disegna una linea dritta lunga </em><span class="c008">x</span><em>.</em></p><ol class="enumerate" type=1><li class="li-enumerate"><em>Scrivete una funzione di nome <span class="c003">koch</span> che preveda una tartaruga e una lunghezza come parametri, e che usi la tartaruga per disegnare una curva di Koch della data lunghezza.</em></li><li class="li-enumerate"><em>Scrivete una funzione chiamata <span class="c003">fioccodineve</span> che disegni tre curve di Koch per ottenere il contorno di un fiocco di neve.</em><p><em>Soluzione: </em><a href="http://thinkpython2.com/code/koch.py"><em><span class="c003">http://thinkpython2.com/code/koch.py</span></em></a><em>.</em></p></li><li class="li-enumerate"><em>La curva di Koch può essere generalizzata in alcuni modi. Consultate 
</em><a href="http://it.wikipedia.org/wiki/Curva_di_Koch"><em><span class="c003">http://it.wikipedia.org/wiki/Curva_di_Koch</span></em></a><em> per degli esempi e implementate quello che preferite.</em></li></ol></div>
<p>
<a href="http://amzn.to/Owtmjy">Buy this book at Amazon.com</a>

</td>

<td width=130 valign="top">

<h4>Contribute</h4>
If you would like to make a contribution to support my books,
you can use the button below.  Thank you!

<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
<input type="hidden" name="cmd" value="_s-xclick">
<input type="hidden" name="hosted_button_id" value="RAAYAZ7Y48S2A">
<table>
<tr><td><input type="hidden" name="on0" value="Pay what you want!">Pay what you want:</td></tr><tr><td><select name="os0">
	<option value="Small">Small $1.00 USD</option>
	<option value="Medium">Medium $5.00 USD</option>
	<option value="Large">Large $10.00 USD</option>
	<option value="X-Large">X-Large $20.00 USD</option>
	<option value="XX-Large">XX-Large $50.00 USD</option>
</select> </td></tr>
</table>
<input type="hidden" name="currency_code" value="USD">
<input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_paynow_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
<img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1">
</form>

<p>
<h4>Are you using one of our books in a class?</h4>  We'd like to know
about it.  Please consider filling out <a href="http://spreadsheets.google.com/viewform?formkey=dC0tNUZkMjBEdXVoRGljNm9FRmlTMHc6MA" onClick="javascript: pageTracker._trackPageview('/outbound/survey');">this short survey</a>.

<p>
<br>

<p>
<iframe class="c018" src="http://rcm.amazon.com/e/cm?t=greenteapre01-20&o=1&p=8&l=as1&asins=144933072X&ref=qf_sp_asin_til&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=FFFFFF&bg1=FFFFFF&npa=1&f=ifr" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

<p>
<iframe class="c018" src="http://rcm.amazon.com/e/cm?t=greenteapre01-20&o=1&p=8&l=as1&asins=1449307116&ref=qf_sp_asin_til&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=FFFFFF&bg1=FFFFFF&npa=1&f=ifr" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

<p>
<iframe class="c018" src="http://rcm.amazon.com/e/cm?t=greenteapre01-20&o=1&p=8&l=as1&asins=1449314635&ref=qf_sp_asin_til&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=FFFFFF&bg1=FFFFFF&npa=1&f=ifr" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

<p>
<iframe class="c018" src="http://rcm.amazon.com/e/cm?t=greenteapre01-20&o=1&p=8&l=as1&asins=0521725968&ref=qf_sp_asin_til&fc1=000000&IS2=1&lt1=_blank&m=amazon&lc1=0000FF&bc1=FFFFFF&bg1=FFFFFF&npa=1&f=ifr" scrolling="no" marginwidth="0" marginheight="0" frameborder="0"></iframe>

</td>
</tr>
</table>
<hr>
<a href="thinkpython2005.html"><img src="back.png" ALT="Previous"></a>
<a href="index.html"><img src="up.png" ALT="Up"></a>
<a href="thinkpython2007.html"><img src="next.png" ALT="Next"></a>
</body>
</html>
